fn main() {
    // Iterator consumers
    // // 1. a normal way
    // let s = "Hello, world!";
    // let ch = 'R';
    // let mut contains = false;
    // for c in s.chars() {
    //     if c == ch {
    //         contains = true;
    //     }
    // }
    // print!(
    //     "\"{}\" {} '{}'.",
    //     s,
    //     if contains {
    //         "contains"
    //     } else {
    //         "does not contain"
    //     },
    //     ch
    // );

    // // using ANY consumer
    // let s = "Hello, world!";
    // let ch = 'R';
    // print!(
    //     "\"{}\" {} '{}'.",
    //     s,
    //     if s.chars().any(|c| c == ch) {
    //         "contains"
    //     } else {
    //         "does not contain"
    //     },
    //     ch
    // );

    // // another simple example
    // print!("{} ", [45, 8, -2, 6].iter().any(|n| *n < 0));

    // // ALL  consumer
    // print!("F{} ",[45, 8, 2, 6].iter().all(|n: &i32| -> bool { *n > 0 }));

    // // COUNT  consumer
    // let s = "€èe";
    // print!("{} {}", s.chars().count(), s.len());  // why ?? -> this string contains three characters represented by six bytes

    // // SUM  consumer  -  it requires a type parameter in angle brackets
    // //  the sum function is applicable only to iterators that produce addable items.
    // print!("{}", [45, 8, -2, 6].iter().sum::<i32>());
    // //OR
    // let s: i32 = [45, 8, -2, 6].iter().sum();
    // print!("{}", s);

    // //  min and max Iterator Consumers
    // // -> produce an Option value, which is Some number if they are applied to a non-empty sequence of numbers, but it is None if it is applied to an empty sequence.
    // let arr = [45, 8, -2, 6];
    // match arr.iter().min() {
    //     // same for max
    //     Some(n) => print!("{} ", n),
    //     _ => (),
    // }

    // match [0; 0].iter().min() {   // for empty arr
    //     Some(n) => print!("{} ", n),
    //     _ => print!("---"),
    // }

    // // COLLECT Consumer
    // let s = "Hello";
    // println!("{:?}", s.chars().collect::<String>());
    // println!("{:?}", s.chars().collect::<Vec<char>>());
    // println!("{:?}", s.bytes().collect::<Vec<u8>>());
    // println!("{:?}", s.as_bytes().iter().collect::<Vec<&u8>>());

    // let arr = [36, 1, 15, 9, 4];
    // let v = arr.iter().collect::<Vec<_>>(); // Rust is able to infer the type &i32
    // print!("{:?}", v);
    // // Notice that the collect function cannot be used to put the iterated items into a static string, an array, or a slice, because it needs to allocate the needed space at runtime.

    //  Iterator Chains - it means that using iterator generated on the iterator generated by another iterator
    let arr = [66, -8, 43, 19, 0, -31];
    let mut v = vec![];
    for n in arr.iter().filter(|x| **x > 0).map(|x| *x * 2) {
        v.push(n);
    }
    print!("{:?}", v);

    /*

        We saw several iterator generators: iter, iter_mut, chars, bytes; and we saw ranges,
    which are iterators with no need to be created by a generator.
     We saw several iterator adapters: filter, map, enumerate.
     And we saw several iterator consumers: any, all, count, sum, min, max, collect.

         */

    // //  Iterators Are “Lazy”  - they process data only when another function asks them for an item, means i will be there if you need me otherwise just thing that i am not there.
    // // example 1:  this will give warning until unless you use the result return by this
    // [66, -8, 43, 19, 0, -31]
    //     .iter()
    //     .filter(|x| {
    //         print!("F{} ", x);
    //         **x > 0
    //     })
    //     .map(|x| {
    //         print!("M{} ", x);
    //         *x * 2
    //     });
    // end
}
